/**
 * Large Examples Ground Truth Validation Tests
 *
 * These tests validate the C++ implementation against ground truth data
 * generated by the original Julia/PyCall implementation (DelaunayInterfaces.jl).
 *
 * The Julia implementation uses the 'diode' Python package for computing
 * weighted alpha shapes. Ground truth was generated using:
 *   DelaunayInterfaces.jl/generate_ground_truth.jl
 *
 * Test categories:
 * - Protein interfaces (4bmg_dimer, 6r7m_quad) with weighted alpha/Delaunay
 * - Random point clouds with various colorings and all three modes:
 *   - Weighted Alpha Complex (weighted=true, alpha=true)
 *   - Weighted Delaunay (weighted=true, alpha=false)
 *   - Unweighted Delaunay (weighted=false, alpha=false)
 *
 * NOTE: These expected values are NOT hand-calculated. They are the output
 * of the reference Julia implementation and serve to verify that the C++
 * port produces identical results.
 */

#include <iostream>
#include <fstream>
#include <cassert>
#include <cmath>
#include <vector>
#include <algorithm>
#include <set>
#include <string>
#include <nlohmann/json.hpp>
#include <delaunay_interfaces/interface_generation.hpp>

using namespace delaunay_interfaces;
using json = nlohmann::json;

constexpr double TOLERANCE = 1e-8;

bool approx_equal(double a, double b, double tol = TOLERANCE) {
    return std::abs(a - b) < tol;
}

struct TestResult {
    bool passed;
    std::string message;
    size_t computed_vertices;
    size_t expected_vertices;
    size_t computed_simplices;
    size_t expected_simplices;
};

TestResult run_ground_truth_test(const std::string& name, const json& test_data) {
    TestResult result;
    result.passed = false;

    try {
        // Extract input data
        const auto& input = test_data["input"];
        const auto& output = test_data["output"];

        // Parse points
        Points points;
        for (const auto& p : input["points"]) {
            points.push_back({p[0].get<double>(), p[1].get<double>(), p[2].get<double>()});
        }

        // Parse color labels
        ColorLabels colors;
        for (const auto& c : input["color_labels"]) {
            colors.push_back(c.get<int>());
        }

        // Parse radii
        Radii radii;
        for (const auto& r : input["radii"]) {
            radii.push_back(r.get<double>());
        }

        bool weighted = input["weighted"].get<bool>();
        bool alpha = input["alpha"].get<bool>();

        // Get expected results
        result.expected_vertices = output["num_vertices"].get<size_t>();
        result.expected_simplices = output["num_simplices"].get<size_t>();

        // Run C++ implementation
        InterfaceGenerator generator;
        auto surface = generator.compute_interface_surface(points, colors, radii, weighted, alpha);

        result.computed_vertices = surface.vertices.size();
        result.computed_simplices = surface.filtration.size();

        // Check counts
        if (result.computed_vertices != result.expected_vertices) {
            result.message = "Vertex count mismatch: " + std::to_string(result.computed_vertices) +
                             " vs expected " + std::to_string(result.expected_vertices);
            return result;
        }

        if (result.computed_simplices != result.expected_simplices) {
            result.message = "Simplex count mismatch: " + std::to_string(result.computed_simplices) +
                             " vs expected " + std::to_string(result.expected_simplices);
            return result;
        }

        // For non-empty results, also verify vertices and filtration values
        if (result.expected_vertices > 0) {
            // Extract expected vertices
            std::vector<std::vector<double>> expected_vertices;
            for (const auto& v : output["vertices"]) {
                expected_vertices.push_back({v[0].get<double>(), v[1].get<double>(), v[2].get<double>()});
            }

            // Sort both for comparison
            std::vector<std::vector<double>> computed_sorted;
            for (const auto& p : surface.vertices) {
                computed_sorted.push_back({p.x(), p.y(), p.z()});
            }
            std::sort(computed_sorted.begin(), computed_sorted.end());
            std::sort(expected_vertices.begin(), expected_vertices.end());

            // Compare vertices
            for (size_t i = 0; i < computed_sorted.size(); ++i) {
                for (size_t j = 0; j < 3; ++j) {
                    if (!approx_equal(computed_sorted[i][j], expected_vertices[i][j])) {
                        result.message = "Vertex " + std::to_string(i) + " coord " + std::to_string(j) +
                                         " mismatch: " + std::to_string(computed_sorted[i][j]) +
                                         " vs " + std::to_string(expected_vertices[i][j]);
                        return result;
                    }
                }
            }

            // Compare filtration values
            std::multiset<double> computed_values, expected_values;
            for (const auto& [simplex, val] : surface.filtration) {
                computed_values.insert(val);
            }
            for (const auto& f : output["filtration"]) {
                expected_values.insert(f["value"].get<double>());
            }

            auto c_it = computed_values.begin();
            auto e_it = expected_values.begin();
            while (c_it != computed_values.end() && e_it != expected_values.end()) {
                if (!approx_equal(*c_it, *e_it)) {
                    result.message = "Filtration value mismatch: " + std::to_string(*c_it) +
                                     " vs " + std::to_string(*e_it);
                    return result;
                }
                ++c_it;
                ++e_it;
            }
        }

        result.passed = true;
        result.message = "OK";
    } catch (const std::exception& e) {
        result.message = std::string("Exception: ") + e.what();
    }

    return result;
}

bool test_protein_example(const std::string& name, const std::string& mode) {
    std::string full_name = name + "_" + mode;
    std::cout << "Test: " << full_name << "\n";

    std::string filepath = std::string(TEST_DATA_DIR) + "/ground_truth_" + full_name + ".json";
    std::ifstream file(filepath);
    if (!file.is_open()) {
        std::cout << "  SKIP: Could not open " << filepath << "\n";
        return true; // Skip, don't fail
    }

    json data = json::parse(file);
    auto result = run_ground_truth_test(full_name, data);

    std::cout << "  Computed: " << result.computed_vertices << " vertices, "
              << result.computed_simplices << " simplices\n";
    std::cout << "  Expected: " << result.expected_vertices << " vertices, "
              << result.expected_simplices << " simplices\n";

    if (result.passed) {
        std::cout << "  PASS\n";
    } else {
        std::cout << "  FAIL: " << result.message << "\n";
    }

    return result.passed;
}

bool test_random_examples() {
    std::cout << "\nRandom Point Cloud Tests\n";
    std::cout << "========================\n";

    std::string filepath = std::string(TEST_DATA_DIR) + "/ground_truth_random.json";
    std::ifstream file(filepath);
    if (!file.is_open()) {
        std::cout << "SKIP: Could not open " << filepath << "\n";
        return true;
    }

    json data = json::parse(file);
    bool all_passed = true;

    for (auto& [name, test_data] : data.items()) {
        std::cout << "\nTest: " << name << "\n";

        auto result = run_ground_truth_test(name, test_data);

        std::cout << "  Computed: " << result.computed_vertices << " vertices, "
                  << result.computed_simplices << " simplices\n";
        std::cout << "  Expected: " << result.expected_vertices << " vertices, "
                  << result.expected_simplices << " simplices\n";

        if (result.passed) {
            std::cout << "  PASS\n";
        } else {
            std::cout << "  FAIL: " << result.message << "\n";
            all_passed = false;
        }
    }

    return all_passed;
}

int main() {
    std::cout << "Large Examples Ground Truth Tests\n";
    std::cout << "==================================\n";
    std::cout << "Comparing C++ output against Julia reference implementation\n\n";

    bool all_passed = true;

    // Test protein examples - Weighted Alpha Complex
    std::cout << "Protein Interface Tests (Weighted Alpha Complex)\n";
    std::cout << "------------------------------------------------\n";

    if (!test_protein_example("4bmg_dimer", "alpha")) all_passed = false;
    if (!test_protein_example("6r7m_quad", "alpha")) all_passed = false;

    // Test protein examples - Weighted Delaunay (no alpha filtering)
    std::cout << "\nProtein Interface Tests (Weighted Delaunay)\n";
    std::cout << "-------------------------------------------\n";

    if (!test_protein_example("4bmg_dimer", "delaunay")) all_passed = false;

    // Test random point cloud examples (includes alpha, delaunay, and unweighted)
    if (!test_random_examples()) all_passed = false;

    std::cout << "\n";
    if (all_passed) {
        std::cout << "All large example tests passed!\n";
        return 0;
    } else {
        std::cout << "Some tests FAILED!\n";
        return 1;
    }
}
