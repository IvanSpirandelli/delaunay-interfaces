/**
 * Ground Truth Validation Tests
 *
 * These tests validate the C++ implementation against ground truth data
 * generated by the original Julia/PyCall implementation (DelaunayInterfaces.jl).
 *
 * The Julia implementation uses the 'diode' Python package for computing
 * weighted alpha shapes. Ground truth was generated using:
 *   DelaunayInterfaces.jl/generate_ground_truth.jl
 *
 * NOTE: These expected values are NOT hand-calculated. They are the output
 * of the reference Julia implementation and serve to verify that the C++
 * port produces identical results.
 */

#include <iostream>
#include <cassert>
#include <cmath>
#include <vector>
#include <algorithm>
#include <set>
#include <delaunay_interfaces/interface_generation.hpp>

using namespace delaunay_interfaces;

constexpr double TOLERANCE = 1e-10;

bool approx_equal(double a, double b, double tol = TOLERANCE) {
    return std::abs(a - b) < tol;
}

bool vertices_match(const Points& computed, const std::vector<std::vector<double>>& expected) {
    if (computed.size() != expected.size()) {
        std::cout << "    Vertex count mismatch: " << computed.size() << " vs " << expected.size() << "\n";
        return false;
    }

    // Sort both by coordinates for comparison (order may differ)
    std::vector<std::vector<double>> computed_sorted;
    for (const auto& p : computed) {
        computed_sorted.push_back({p.x(), p.y(), p.z()});
    }
    std::sort(computed_sorted.begin(), computed_sorted.end());

    auto expected_sorted = expected;
    std::sort(expected_sorted.begin(), expected_sorted.end());

    for (size_t i = 0; i < computed_sorted.size(); ++i) {
        for (size_t j = 0; j < 3; ++j) {
            if (!approx_equal(computed_sorted[i][j], expected_sorted[i][j])) {
                std::cout << "    Vertex " << i << " coord " << j << " mismatch: "
                          << computed_sorted[i][j] << " vs " << expected_sorted[i][j] << "\n";
                return false;
            }
        }
    }
    return true;
}

bool filtration_values_match(const Filtration& computed,
                             const std::vector<std::pair<std::vector<int32_t>, double>>& expected) {
    if (computed.size() != expected.size()) {
        std::cout << "    Filtration count mismatch: " << computed.size() << " vs " << expected.size() << "\n";
        return false;
    }

    // Collect all filtration values (sorted for comparison)
    std::multiset<double> computed_values, expected_values;
    for (const auto& [simplex, val] : computed) {
        computed_values.insert(val);
    }
    for (const auto& [simplex, val] : expected) {
        expected_values.insert(val);
    }

    auto c_it = computed_values.begin();
    auto e_it = expected_values.begin();
    while (c_it != computed_values.end() && e_it != expected_values.end()) {
        if (!approx_equal(*c_it, *e_it)) {
            std::cout << "    Filtration value mismatch: " << *c_it << " vs " << *e_it << "\n";
            return false;
        }
        ++c_it;
        ++e_it;
    }

    return true;
}

// Ground truth data from Julia implementation
// tetra_2_2: 2-2 partition [u,v] vs [x,y]
void test_tetra_2_2() {
    std::cout << "Test: tetra_2_2 (2-2 partition)\n";

    Points points = {
        {0.0, 0.0, 0.0},
        {2.0, 0.0, 0.0},
        {1.0, 0.0, 2.4},
        {1.0, 3.0, 1.2}
    };
    ColorLabels colors = {1, 1, 2, 2};

    // Expected vertices from ground truth
    std::vector<std::vector<double>> expected_vertices = {
        {0.5, 1.5, 0.6},
        {0.5, 0.0, 1.2},
        {1.5, 0.0, 1.2},
        {1.5, 1.5, 0.6},
        {0.5, 0.75, 0.8999999999999999},
        {1.0, 0.0, 1.2},
        {1.5, 0.75, 0.8999999999999999},
        {1.0, 1.5, 0.6},
        {1.0, 0.75, 0.9}
    };

    // Expected filtration (value only, simplex structure validated separately)
    // Note: indices are 0-based
    std::vector<std::pair<std::vector<int32_t>, double>> expected_filtration = {
        {{0}, 3.3823069050575527},
        {{1}, 2.6},
        {{2}, 2.6},
        {{3}, 3.3823069050575527},
        {{4}, 2.5475478405713994},
        {{5}, 2.4},
        {{6}, 2.5475478405713994},
        {{7}, 3.2310988842807022},
        {{8}, 2.3430749027719964},
        {{0, 4}, 2.5475478405713994},
        {{0, 7}, 3.2310988842807022},
        {{0, 8}, 2.3430749027719964},
        {{1, 4}, 2.5475478405713994},
        {{1, 5}, 2.4},
        {{1, 8}, 2.3430749027719964},
        {{2, 5}, 2.4},
        {{2, 6}, 2.5475478405713994},
        {{2, 8}, 2.3430749027719964},
        {{3, 6}, 2.5475478405713994},
        {{3, 7}, 3.2310988842807022},
        {{3, 8}, 2.3430749027719964},
        {{4, 8}, 2.3430749027719964},
        {{5, 8}, 2.3430749027719964},
        {{6, 8}, 2.3430749027719964},
        {{7, 8}, 2.3430749027719964},
        {{8, 0, 4}, 2.3430749027719964},
        {{8, 1, 5}, 2.3430749027719964},
        {{8, 2, 6}, 2.3430749027719964},
        {{8, 3, 7}, 2.3430749027719964},
        {{8, 4, 1}, 2.3430749027719964},
        {{8, 5, 2}, 2.3430749027719964},
        {{8, 6, 3}, 2.3430749027719964},
        {{8, 7, 0}, 2.3430749027719964}
    };

    InterfaceGenerator generator;
    auto surface = generator.compute_interface_surface(points, colors, {}, false, false);

    std::cout << "  Computed: " << surface.vertices.size() << " vertices, "
              << surface.filtration.size() << " simplices\n";
    std::cout << "  Expected: " << expected_vertices.size() << " vertices, "
              << expected_filtration.size() << " simplices\n";

    bool verts_ok = vertices_match(surface.vertices, expected_vertices);
    bool filt_ok = filtration_values_match(surface.filtration, expected_filtration);

    if (verts_ok && filt_ok) {
        std::cout << "  PASS\n";
    } else {
        std::cout << "  FAIL\n";
        exit(1);
    }
}

// tetra_3_1: 3-1 partition [u,v,w] vs [x]
void test_tetra_3_1() {
    std::cout << "Test: tetra_3_1 (3-1 partition)\n";

    Points points = {
        {0.0, 0.0, 0.0},
        {2.0, 0.0, 0.0},
        {1.0, 0.0, 2.4},
        {1.0, 3.0, 1.2}
    };
    ColorLabels colors = {1, 1, 1, 2};

    std::vector<std::vector<double>> expected_vertices = {
        {1.0, 1.5, 1.7999999999999998},
        {0.5, 1.5, 0.6},
        {1.5, 1.5, 0.6},
        {0.75, 1.5, 1.2},
        {1.0, 1.5, 0.6},
        {1.25, 1.5, 1.2},
        {1.0, 1.5, 1.0}
    };

    // Note: indices are 0-based
    std::vector<std::pair<std::vector<int32_t>, double>> expected_filtration = {
        {{0}, 3.2310988842807022},
        {{1}, 3.3823069050575527},
        {{2}, 3.3823069050575527},
        {{3}, 3.0413812651491097},
        {{4}, 3.2310988842807022},
        {{5}, 3.0413812651491097},
        {{6}, 3.026549190084311},
        {{0, 3}, 3.0413812651491097},
        {{0, 5}, 3.0413812651491097},
        {{0, 6}, 3.026549190084311},
        {{1, 3}, 3.0413812651491097},
        {{1, 4}, 3.2310988842807022},
        {{1, 6}, 3.026549190084311},
        {{2, 4}, 3.2310988842807022},
        {{2, 5}, 3.0413812651491097},
        {{2, 6}, 3.026549190084311},
        {{3, 6}, 3.026549190084311},
        {{4, 6}, 3.026549190084311},
        {{5, 6}, 3.026549190084311},
        {{6, 0, 3}, 3.026549190084311},
        {{6, 1, 4}, 3.026549190084311},
        {{6, 2, 5}, 3.026549190084311},
        {{6, 3, 1}, 3.026549190084311},
        {{6, 4, 2}, 3.026549190084311},
        {{6, 5, 0}, 3.026549190084311}
    };

    InterfaceGenerator generator;
    auto surface = generator.compute_interface_surface(points, colors, {}, false, false);

    std::cout << "  Computed: " << surface.vertices.size() << " vertices, "
              << surface.filtration.size() << " simplices\n";
    std::cout << "  Expected: " << expected_vertices.size() << " vertices, "
              << expected_filtration.size() << " simplices\n";

    bool verts_ok = vertices_match(surface.vertices, expected_vertices);
    bool filt_ok = filtration_values_match(surface.filtration, expected_filtration);

    if (verts_ok && filt_ok) {
        std::cout << "  PASS\n";
    } else {
        std::cout << "  FAIL\n";
        exit(1);
    }
}

// tetra_2_1_1: 2-1-1 partition [a,b] vs [u] vs [x]
void test_tetra_2_1_1() {
    std::cout << "Test: tetra_2_1_1 (2-1-1 partition)\n";

    Points points = {
        {0.1, 0.1, 0.1},
        {2.0, 0.0, 0.2},
        {1.0, 2.5, 0.0},
        {1.0, 1.4, 1.0}
    };
    ColorLabels colors = {1, 1, 2, 3};

    std::vector<std::vector<double>> expected_vertices = {
        {0.55, 1.3, 0.05},
        {0.55, 0.75, 0.55},
        {1.5, 0.7, 0.6},
        {1.5, 1.25, 0.1},
        {1.0, 1.95, 0.5},
        {0.7000000000000001, 1.3333333333333333, 0.3666666666666667},
        {1.025, 0.725, 0.575},
        {1.3333333333333333, 1.3, 0.39999999999999997},
        {1.025, 1.275, 0.07500000000000001},
        {1.02, 1.19, 0.36000000000000004}
    };

    // Note: indices are 0-based
    std::vector<std::pair<std::vector<int32_t>, double>> expected_filtration = {
        {{0}, 2.565151067676132},
        {{1}, 1.8193405398660252},
        {{2}, 1.8973665961010275},
        {{3}, 2.7},
        {{4}, 1.4866068747318506},
        {{5}, 1.9570328274246693},
        {{6}, 1.5960889699512368},
        {{7}, 2.0279911569442928},
        {{8}, 2.4550967394381837},
        {{9}, 1.845930861373757},
        {{0, 5}, 1.9570328274246693},
        {{0, 8}, 2.4550967394381837},
        {{0, 9}, 1.845930861373757},
        {{1, 5}, 1.8193405398660252},
        {{1, 6}, 1.5960889699512368},
        {{1, 9}, 1.8193405398660252},
        {{2, 6}, 1.5960889699512368},
        {{2, 7}, 1.8973665961010275},
        {{2, 9}, 1.845930861373757},
        {{3, 7}, 2.0279911569442928},
        {{3, 8}, 2.4550967394381837},
        {{3, 9}, 1.845930861373757},
        {{4, 5}, 1.4866068747318506},
        {{4, 7}, 1.4866068747318506},
        {{4, 9}, 1.4866068747318506},
        {{5, 9}, 1.845930861373757},
        {{6, 9}, 1.5960889699512368},
        {{7, 9}, 1.845930861373757},
        {{8, 9}, 1.845930861373757},
        {{9, 0, 5}, 1.845930861373757},
        {{9, 1, 6}, 1.5960889699512368},
        {{9, 2, 7}, 1.845930861373757},
        {{9, 3, 8}, 1.845930861373757},
        {{9, 4, 7}, 1.4866068747318506},
        {{9, 5, 1}, 1.8193405398660252},
        {{9, 5, 4}, 1.4866068747318506},
        {{9, 6, 2}, 1.5960889699512368},
        {{9, 7, 3}, 1.845930861373757},
        {{9, 8, 0}, 1.845930861373757}
    };

    InterfaceGenerator generator;
    auto surface = generator.compute_interface_surface(points, colors, {}, false, false);

    std::cout << "  Computed: " << surface.vertices.size() << " vertices, "
              << surface.filtration.size() << " simplices\n";
    std::cout << "  Expected: " << expected_vertices.size() << " vertices, "
              << expected_filtration.size() << " simplices\n";

    bool verts_ok = vertices_match(surface.vertices, expected_vertices);
    bool filt_ok = filtration_values_match(surface.filtration, expected_filtration);

    if (verts_ok && filt_ok) {
        std::cout << "  PASS\n";
    } else {
        std::cout << "  FAIL\n";
        exit(1);
    }
}

// tetra_1_1_1_1: 1-1-1-1 partition [a] vs [i] vs [u] vs [x]
void test_tetra_1_1_1_1() {
    std::cout << "Test: tetra_1_1_1_1 (1-1-1-1 partition)\n";

    Points points = {
        {0.0, 0.0, 0.0},
        {2.0, 0.15, 0.0},
        {1.0, 0.0, 2.4},
        {1.0, 3.0, 2.4}
    };
    ColorLabels colors = {1, 2, 3, 4};

    std::vector<std::vector<double>> expected_vertices = {
        {1.5, 1.575, 1.2},
        {1.0, 1.5, 2.4},
        {0.5, 1.5, 1.2},
        {1.5, 0.075, 1.2},
        {1.0, 0.075, 0.0},
        {0.5, 0.0, 1.2},
        {1.3333333333333333, 1.05, 1.5999999999999999},
        {1.0, 1.05, 0.7999999999999999},
        {1.0, 0.049999999999999996, 0.7999999999999999},
        {0.6666666666666666, 1.0, 1.5999999999999999},
        {1.0, 0.7875000000000001, 1.2}
    };

    // Note: indices are 0-based
    std::vector<std::pair<std::vector<int32_t>, double>> expected_filtration = {
        {{0}, 3.8577843381920665},
        {{1}, 3.0},
        {{2}, 3.9698866482558417},
        {{3}, 2.6043233286210836},
        {{4}, 2.005617112013158},
        {{5}, 2.6},
        {{6}, 3.1540358889377167},
        {{7}, 3.2777626994870217},
        {{8}, 2.403313480211414},
        {{9}, 3.1899622160852807},
        {{10}, 3.0062685711803585},
        {{0, 6}, 3.1540358889377167},
        {{0, 7}, 3.2777626994870217},
        {{0, 10}, 3.0062685711803585},
        {{1, 6}, 3.0},
        {{1, 9}, 3.0},
        {{1, 10}, 3.0},
        {{2, 7}, 3.2777626994870217},
        {{2, 9}, 3.1899622160852807},
        {{2, 10}, 3.0062685711803585},
        {{3, 6}, 2.6043233286210836},
        {{3, 8}, 2.403313480211414},
        {{3, 10}, 2.6043233286210836},
        {{4, 7}, 2.005617112013158},
        {{4, 8}, 2.005617112013158},
        {{4, 10}, 2.005617112013158},
        {{5, 8}, 2.403313480211414},
        {{5, 9}, 2.6},
        {{5, 10}, 2.6},
        {{6, 10}, 3.0062685711803585},
        {{7, 10}, 3.0062685711803585},
        {{8, 10}, 2.403313480211414},
        {{9, 10}, 3.0062685711803585},
        {{10, 0, 6}, 3.0062685711803585},
        {{10, 1, 6}, 3.0},
        {{10, 2, 7}, 3.0062685711803585},
        {{10, 3, 8}, 2.403313480211414},
        {{10, 4, 7}, 2.005617112013158},
        {{10, 5, 9}, 2.6},
        {{10, 6, 3}, 2.6043233286210836},
        {{10, 7, 0}, 3.0062685711803585},
        {{10, 8, 4}, 2.005617112013158},
        {{10, 8, 5}, 2.403313480211414},
        {{10, 9, 1}, 3.0},
        {{10, 9, 2}, 3.0062685711803585}
    };

    InterfaceGenerator generator;
    auto surface = generator.compute_interface_surface(points, colors, {}, false, false);

    std::cout << "  Computed: " << surface.vertices.size() << " vertices, "
              << surface.filtration.size() << " simplices\n";
    std::cout << "  Expected: " << expected_vertices.size() << " vertices, "
              << expected_filtration.size() << " simplices\n";

    bool verts_ok = vertices_match(surface.vertices, expected_vertices);
    bool filt_ok = filtration_values_match(surface.filtration, expected_filtration);

    if (verts_ok && filt_ok) {
        std::cout << "  PASS\n";
    } else {
        std::cout << "  FAIL\n";
        exit(1);
    }
}

int main() {
    std::cout << "Ground Truth Validation Tests\n";
    std::cout << "============================\n";
    std::cout << "Comparing C++ output against Julia reference implementation\n\n";

    try {
        test_tetra_2_2();
        test_tetra_3_1();
        test_tetra_2_1_1();
        test_tetra_1_1_1_1();

        std::cout << "\nAll ground truth tests passed!\n";
        return 0;
    } catch (const std::exception& e) {
        std::cerr << "\nTest failed with exception: " << e.what() << "\n";
        return 1;
    }
}
